
树：
1、根据本节点的访问顺序有三种遍历方法：前序、中序、后序——可以使用DFS\BFS实现遍历；
——dfs：时间复杂度：O(n)O(n)。即遍历这棵树的复杂度。 空间复杂度：O(n)。即递归的栈空间的空间代价

2、Morris Traversal——实现空间复杂度O(1)；

2、二叉搜索树，左节点小于等于本节点、右节点大于等于本节点；——中序遍历后，是非递减的有序序列；

3、遍历加回溯的运用；

4、并查集：

5、动态规划

6、递归运用：考虑递归前、递归返回做什么动作，返回值、出口条件；
void reverse()
    //出口条件
    //递归前动作
    reverse();
    //递归返回时动作
}

7、大堆小堆：
最差情况下插入的时间复杂度为O(logn)；
平均情况下插入的复杂度为O(1)
构造n个元素二叉堆：复杂度为O(nlogn)。

排序:
快排：


STL tricks:
不需要关注相对位置的快速删除vector里面元素：将要删除的元素与结尾元素交换，删除结尾元素；
使用vector也可以模拟stack,并且能正序地遍历整个数据；


链表：
快慢指针找中间点；
归并排序链表O（n(logn)）;
反转： 原地反转，递归反转；

图论：
求解多少个连通分量： bfs/dfs、并查集；
求解是否成环：拓扑排序；
最小生成树： kruskal和prim算法；