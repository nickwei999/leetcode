
树：
1、根据本节点的访问顺序有三种遍历方法：前序、中序、后序——可以使用DFS\BFS实现遍历；
——dfs：时间复杂度：O(n)O(n)。即遍历这棵树的复杂度。 空间复杂度：O(n)。即递归的栈空间的空间代价

2、Morris Traversal——实现空间复杂度O(1)；

2、二叉搜索树，左节点小于等于本节点、右节点大于等于本节点；——中序遍历后，是非递减的有序序列；

3、遍历加回溯的运用；

4、并查集：

5、动态规划

6、递归运用：考虑递归前、递归返回做什么动作，返回值、出口条件；
void reverse()
    //出口条件
    //递归前动作
    reverse();
    //递归返回时动作
}

7、大堆小堆：
最差情况下插入的时间复杂度为O(logn)；
平均情况下插入的复杂度为O(1)
构造n个元素二叉堆：复杂度为O(nlogn)。

排序:
快排：
